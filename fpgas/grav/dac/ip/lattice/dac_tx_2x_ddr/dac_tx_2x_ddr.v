/* Verilog netlist generated by SCUBA Diamond (64-bit) 3.9.1.119 */
/* Module Version: 5.8 */
/* C:\lscc\diamond\3.9_x64\ispfpga\bin\nt64\scuba.exe -w -n dac_tx_2x_ddr -lang verilog -synth synplify -bus_exp 7 -bb -arch sa5p00 -type iol -mode Transmit -io_type LVDS -width 17 -freq_in 250 -gear 4 -del -1 -pll 125 -fdc C:/FPGA/higgs_sdr_rev2-ryan/fpgas/grav/dac/ip/lattice/dac_tx_2x_ddr/dac_tx_2x_ddr.fdc  */
/* Thu Nov 02 22:54:47 2017 */


// ============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2013 Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorized by
// a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement 
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation      TEL  : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                           408-826-6000 (other locations)
// Hillsboro, OR 97124                    web  : http://www.latticesemi.com/
// U.S.A                                  email: techsupport@latticesemi.com
// =============================================================================
// Module     : gddr_sync.v
// Description: 
//   - Code for bus synchronization
//   - Needed to tolerate large skew between stop and ddr and clkdiv reset
// =============================================================================

`timescale 1ns/1ps

module dac_tx_2x_ddrgddr_sync (
  // inputs
  rst,             // Asynchronous reset
  sync_clk,        // oscillator clk or other constant running low speed clk.
                   // note that this clk should not be coming from clk sources 
                   // that this module will stop or reset (e.g. ECLKSYNC, CLKDIV)
  start,           // Initialize the sync process

  // outputs
  stop,            // ECLKSYNC.stop signal
  ddr_reset,       // DDR and CLKDIV reset signal
  ready            // READY signal; clock sync is done.
);

//-----------------------------------------------------------------------------
// PORTS DECLARATIONS
//----------------------------------------------------------------------------- 
// input ports
input       rst;
input       sync_clk;
input       start;

// output ports
output      stop;
output      ddr_reset;
output      ready;

//-----------------------------------------------------------------------------
// PARAMETERS
//-----------------------------------------------------------------------------        
// Local parameters: States
localparam INIT   = 3'b000;
localparam STOP   = 3'b001;
localparam RESET  = 3'b011;
localparam READY  = 3'b100;

//----------------------------------------------------------------------------- 
// SIGNAL DECLARATIONS
//-----------------------------------------------------------------------------  
wire        rst;
wire        sync_clk;
wire        start;
wire        ddr_reset;     
wire        stop;
wire        ready;

reg         ddr_reset_d;
reg   [3:0] ctrl_cnt;                                    // control counter
reg   [2:0] stop_assert;                                 // stop signal counter
reg   [2:0] cs_gddr_sync /*synthesis syn_preserve=1*/ ;  // current state
reg   [2:0] ns_gddr_sync;                                // next state
reg         reset_flag;                                  // flag signal that 
                                                         // indicates that RESET 
                                                         // is already done
  
//----------------------------------------------------------------------------- 
//  WIRE ASSIGNMENTS
//-----------------------------------------------------------------------------       
assign stop      = cs_gddr_sync[0];              
assign ddr_reset = cs_gddr_sync[1] | ddr_reset_d;
assign ready     = cs_gddr_sync[2];

//----------------------------------------------------------------------------- 
//  REGISTER ASSIGNMENTS
//-----------------------------------------------------------------------------  
always @(posedge sync_clk or posedge rst) begin
  if (rst==1'b1)
  begin
    cs_gddr_sync  <= INIT;
    ctrl_cnt      <= 4'd0;
    stop_assert   <= 3'd0;
    reset_flag    <= 1'b0;
    ddr_reset_d   <= 1'b1;
  end
  else
  begin
    cs_gddr_sync  <= ns_gddr_sync;
    ddr_reset_d   <= 1'b0;

    // CTRL_CNT for state machines        
    if (((cs_gddr_sync==INIT)&&(reset_flag==1'b0))||((ctrl_cnt == 3)
         &&(cs_gddr_sync!=INIT)))    
    begin          
      ctrl_cnt <= 'd0;
    end
    else if (ctrl_cnt < 8)
    begin          
      ctrl_cnt <= ctrl_cnt + 1;
    end
        
    // STOP signal will then be asserted 4T after rstn
    if ((!rst)&&(start)&&(stop_assert<4)&&(reset_flag==1'b0))               
    begin            
      stop_assert <= stop_assert + 1;
    end

    // Asserts the reset_flag after RESET state
    if ((cs_gddr_sync==RESET)&&(ns_gddr_sync == STOP))    
    begin
      reset_flag <= 1'b1;            
    end

    // Deasserts the reset_flag after READY state            
    if ((cs_gddr_sync==READY)&&(ns_gddr_sync == INIT))    
    begin
      reset_flag <= 1'b0;            
    end                    
  end
end

// GDDR_SYNC State machine    
always @(*) begin
  
  case (cs_gddr_sync)  /* synthesis full_case parallel_case */
    INIT:  // INIT state 0
    begin
      if ((start)&&(stop_assert==3)&&(reset_flag==1'b0))
      begin
        ns_gddr_sync = STOP;
      end
      else if ((reset_flag==1'b1)&&(ctrl_cnt == 7)&&(start))
      begin
        ns_gddr_sync = READY;
      end
      else
      begin
        ns_gddr_sync = INIT;
      end
    end
    
    STOP:  //STOP state 1
    begin
      if (ctrl_cnt == 3)
      begin
        if (reset_flag ==1'b1)
        begin
          ns_gddr_sync  = INIT;
        end
        else
        begin
          ns_gddr_sync  = RESET;
        end
      end
      else
      begin
        ns_gddr_sync = STOP;
      end
    end    
    
    RESET:  // RESET state 2
    begin
      if (ctrl_cnt == 3)
      begin
        ns_gddr_sync = STOP;
      end
      else
      begin
        ns_gddr_sync = RESET;
      end
    end
    
    READY:  // READY state 5
    begin
      if ((!start))
      begin
        ns_gddr_sync = INIT;
      end
      else
      begin
        ns_gddr_sync = READY;
      end
    end
    
    default:
    begin
      ns_gddr_sync = cs_gddr_sync;
    end
    
  endcase
end
  
endmodule // dac_tx_2x_ddrgddr_sync


`timescale 1 ns / 1 ps
module dac_tx_2x_ddr (clkout, pll_reset, ready, refclk, sclk, sync_clk, 
    sync_reset, data, dout)/* synthesis NGD_DRC_MASK=1 */;
    input wire pll_reset;
    input wire refclk;
    input wire sync_clk;
    input wire sync_reset;
    input wire [67:0] data;
    output wire clkout;
    output wire ready;
    output wire sclk;
    output wire [16:0] dout;

    wire da16;
    wire db16;
    wire dc16;
    wire dd16;
    wire da15;
    wire db15;
    wire dc15;
    wire dd15;
    wire da14;
    wire db14;
    wire dc14;
    wire dd14;
    wire da13;
    wire db13;
    wire dc13;
    wire dd13;
    wire da12;
    wire db12;
    wire dc12;
    wire dd12;
    wire da11;
    wire db11;
    wire dc11;
    wire dd11;
    wire da10;
    wire db10;
    wire dc10;
    wire dd10;
    wire da9;
    wire db9;
    wire dc9;
    wire dd9;
    wire da8;
    wire db8;
    wire dc8;
    wire dd8;
    wire da7;
    wire db7;
    wire dc7;
    wire dd7;
    wire da6;
    wire db6;
    wire dc6;
    wire dd6;
    wire da5;
    wire db5;
    wire dc5;
    wire dd5;
    wire da4;
    wire db4;
    wire dc4;
    wire dd4;
    wire da3;
    wire db3;
    wire dc3;
    wire dd3;
    wire da2;
    wire db2;
    wire dc2;
    wire dd2;
    wire da1;
    wire db1;
    wire dc1;
    wire dd1;
    wire da0;
    wire db0;
    wire dc0;
    wire dd0;
    wire scuba_vhi;
    wire sclk_t;
    wire reset;
    wire eclko;
    wire stop;
    wire lock_chk;
    wire clkos;
    wire clkop;
    wire scuba_vlo;
    wire clkintfb;
    wire pllclki;
    wire buf_clkout;
    wire buf_douto16;
    wire buf_douto15;
    wire buf_douto14;
    wire buf_douto13;
    wire buf_douto12;
    wire buf_douto11;
    wire buf_douto10;
    wire buf_douto9;
    wire buf_douto8;
    wire buf_douto7;
    wire buf_douto6;
    wire buf_douto5;
    wire buf_douto4;
    wire buf_douto3;
    wire buf_douto2;
    wire buf_douto1;
    wire buf_douto0;

    dac_tx_2x_ddrgddr_sync Inst_gddr_sync (.rst(sync_reset), .sync_clk(sync_clk), 
        .start(lock_chk), .stop(stop), .ddr_reset(reset), .ready(ready));

    ODDRX2F Inst7_ODDRX2F16 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd16), 
        .D2(dc16), .D1(db16), .D0(da16), .Q(buf_douto16));

    ODDRX2F Inst7_ODDRX2F15 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd15), 
        .D2(dc15), .D1(db15), .D0(da15), .Q(buf_douto15));

    ODDRX2F Inst7_ODDRX2F14 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd14), 
        .D2(dc14), .D1(db14), .D0(da14), .Q(buf_douto14));

    ODDRX2F Inst7_ODDRX2F13 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd13), 
        .D2(dc13), .D1(db13), .D0(da13), .Q(buf_douto13));

    ODDRX2F Inst7_ODDRX2F12 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd12), 
        .D2(dc12), .D1(db12), .D0(da12), .Q(buf_douto12));

    ODDRX2F Inst7_ODDRX2F11 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd11), 
        .D2(dc11), .D1(db11), .D0(da11), .Q(buf_douto11));

    ODDRX2F Inst7_ODDRX2F10 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd10), 
        .D2(dc10), .D1(db10), .D0(da10), .Q(buf_douto10));

    ODDRX2F Inst7_ODDRX2F9 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd9), 
        .D2(dc9), .D1(db9), .D0(da9), .Q(buf_douto9));

    ODDRX2F Inst7_ODDRX2F8 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd8), 
        .D2(dc8), .D1(db8), .D0(da8), .Q(buf_douto8));

    ODDRX2F Inst7_ODDRX2F7 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd7), 
        .D2(dc7), .D1(db7), .D0(da7), .Q(buf_douto7));

    ODDRX2F Inst7_ODDRX2F6 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd6), 
        .D2(dc6), .D1(db6), .D0(da6), .Q(buf_douto6));

    ODDRX2F Inst7_ODDRX2F5 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd5), 
        .D2(dc5), .D1(db5), .D0(da5), .Q(buf_douto5));

    ODDRX2F Inst7_ODDRX2F4 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd4), 
        .D2(dc4), .D1(db4), .D0(da4), .Q(buf_douto4));

    ODDRX2F Inst7_ODDRX2F3 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd3), 
        .D2(dc3), .D1(db3), .D0(da3), .Q(buf_douto3));

    ODDRX2F Inst7_ODDRX2F2 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd2), 
        .D2(dc2), .D1(db2), .D0(da2), .Q(buf_douto2));

    ODDRX2F Inst7_ODDRX2F1 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd1), 
        .D2(dc1), .D1(db1), .D0(da1), .Q(buf_douto1));

    ODDRX2F Inst7_ODDRX2F0 (.SCLK(sclk_t), .ECLK(eclko), .RST(reset), .D3(dd0), 
        .D2(dc0), .D1(db0), .D0(da0), .Q(buf_douto0));

    VHI scuba_vhi_inst (.Z(scuba_vhi));

    ODDRX2F Inst6_ODDRX2F (.SCLK(sclk_t), .ECLK(clkos), .RST(reset), .D3(scuba_vlo), 
        .D2(scuba_vhi), .D1(scuba_vlo), .D0(scuba_vhi), .Q(buf_clkout));

    defparam Inst5_CLKDIVF.DIV = "2.0" ;
    CLKDIVF Inst5_CLKDIVF (.CLKI(eclko), .RST(reset), .ALIGNWD(scuba_vlo), 
        .CDIVX(sclk_t));

    ECLKSYNCB Inst4_ECLKSYNCB (.ECLKI(clkop), .STOP(stop), .ECLKO(eclko));

    VLO scuba_vlo_inst (.Z(scuba_vlo));

    defparam Inst3_EHXPLLL.PLLRST_ENA = "ENABLED" ;
    defparam Inst3_EHXPLLL.INTFB_WAKE = "DISABLED" ;
    defparam Inst3_EHXPLLL.STDBY_ENABLE = "DISABLED" ;
    defparam Inst3_EHXPLLL.DPHASE_SOURCE = "DISABLED" ;
    defparam Inst3_EHXPLLL.CLKOS3_FPHASE = 0 ;
    defparam Inst3_EHXPLLL.CLKOS3_CPHASE = 0 ;
    defparam Inst3_EHXPLLL.CLKOS2_FPHASE = 0 ;
    defparam Inst3_EHXPLLL.CLKOS2_CPHASE = 0 ;
    defparam Inst3_EHXPLLL.CLKOS_FPHASE = 4 ; // was 4 changed by Ameet
    defparam Inst3_EHXPLLL.CLKOS_CPHASE = 1 ; // was 1 changed by Ameet
    defparam Inst3_EHXPLLL.CLKOP_FPHASE = 0 ;
    defparam Inst3_EHXPLLL.CLKOP_CPHASE = 1 ;
    defparam Inst3_EHXPLLL.PLL_LOCK_MODE = 0 ;
    defparam Inst3_EHXPLLL.CLKOS_TRIM_DELAY = 0 ;
    defparam Inst3_EHXPLLL.CLKOS_TRIM_POL = "RISING" ;
    defparam Inst3_EHXPLLL.CLKOP_TRIM_DELAY = 0 ;
    defparam Inst3_EHXPLLL.CLKOP_TRIM_POL = "RISING" ;
    defparam Inst3_EHXPLLL.OUTDIVIDER_MUXD = "DIVD" ;
    defparam Inst3_EHXPLLL.CLKOS3_ENABLE = "DISABLED" ;
    defparam Inst3_EHXPLLL.OUTDIVIDER_MUXC = "DIVC" ;
    defparam Inst3_EHXPLLL.CLKOS2_ENABLE = "DISABLED" ;
    defparam Inst3_EHXPLLL.OUTDIVIDER_MUXB = "DIVB" ;
    defparam Inst3_EHXPLLL.CLKOS_ENABLE = "ENABLED" ;
    defparam Inst3_EHXPLLL.OUTDIVIDER_MUXA = "DIVA" ;
    defparam Inst3_EHXPLLL.CLKOP_ENABLE = "ENABLED" ;
    defparam Inst3_EHXPLLL.CLKOS3_DIV = 1 ;
    defparam Inst3_EHXPLLL.CLKOS2_DIV = 1 ;
    defparam Inst3_EHXPLLL.CLKOS_DIV = 2 ;
    defparam Inst3_EHXPLLL.CLKOP_DIV = 2 ;
    defparam Inst3_EHXPLLL.CLKFB_DIV = 2 ;
    defparam Inst3_EHXPLLL.CLKI_DIV = 1 ;
    defparam Inst3_EHXPLLL.FEEDBK_PATH = "INT_OP" ;
    EHXPLLL Inst3_EHXPLLL (.CLKI(pllclki), .CLKFB(clkintfb), .PHASESEL1(scuba_vlo), 
        .PHASESEL0(scuba_vlo), .PHASEDIR(scuba_vlo), .PHASESTEP(scuba_vlo), 
        .PHASELOADREG(scuba_vlo), .STDBY(scuba_vlo), .PLLWAKESYNC(scuba_vlo), 
        .RST(pll_reset), .ENCLKOP(scuba_vlo), .ENCLKOS(scuba_vlo), .ENCLKOS2(scuba_vlo), 
        .ENCLKOS3(scuba_vlo), .CLKOP(clkop), .CLKOS(clkos), .CLKOS2(), .CLKOS3(), 
        .LOCK(lock_chk), .INTLOCK(), .REFCLK(), .CLKINTFB(clkintfb))
             /* synthesis FREQUENCY_PIN_CLKOS="250.000000" */
             /* synthesis FREQUENCY_PIN_CLKOP="250.000000" */
             /* synthesis FREQUENCY_PIN_CLKI="125.000000" */
             /* synthesis ICP_CURRENT="10" */
             /* synthesis LPF_RESISTOR="24" */;

    OB Inst2_OB (.I(buf_clkout), .O(clkout))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB16 (.I(buf_douto16), .O(dout[16]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB15 (.I(buf_douto15), .O(dout[15]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB14 (.I(buf_douto14), .O(dout[14]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB13 (.I(buf_douto13), .O(dout[13]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB12 (.I(buf_douto12), .O(dout[12]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB11 (.I(buf_douto11), .O(dout[11]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB10 (.I(buf_douto10), .O(dout[10]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB9 (.I(buf_douto9), .O(dout[9]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB8 (.I(buf_douto8), .O(dout[8]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB7 (.I(buf_douto7), .O(dout[7]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB6 (.I(buf_douto6), .O(dout[6]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB5 (.I(buf_douto5), .O(dout[5]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB4 (.I(buf_douto4), .O(dout[4]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB3 (.I(buf_douto3), .O(dout[3]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB2 (.I(buf_douto2), .O(dout[2]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB1 (.I(buf_douto1), .O(dout[1]))
             /* synthesis IO_TYPE="LVDS" */;

    OB Inst1_OB0 (.I(buf_douto0), .O(dout[0]))
             /* synthesis IO_TYPE="LVDS" */;

    assign sclk = sclk_t;
    assign dd16 = data[67];
    assign dd15 = data[66];
    assign dd14 = data[65];
    assign dd13 = data[64];
    assign dd12 = data[63];
    assign dd11 = data[62];
    assign dd10 = data[61];
    assign dd9 = data[60];
    assign dd8 = data[59];
    assign dd7 = data[58];
    assign dd6 = data[57];
    assign dd5 = data[56];
    assign dd4 = data[55];
    assign dd3 = data[54];
    assign dd2 = data[53];
    assign dd1 = data[52];
    assign dd0 = data[51];
    assign dc16 = data[50];
    assign dc15 = data[49];
    assign dc14 = data[48];
    assign dc13 = data[47];
    assign dc12 = data[46];
    assign dc11 = data[45];
    assign dc10 = data[44];
    assign dc9 = data[43];
    assign dc8 = data[42];
    assign dc7 = data[41];
    assign dc6 = data[40];
    assign dc5 = data[39];
    assign dc4 = data[38];
    assign dc3 = data[37];
    assign dc2 = data[36];
    assign dc1 = data[35];
    assign dc0 = data[34];
    assign db16 = data[33];
    assign db15 = data[32];
    assign db14 = data[31];
    assign db13 = data[30];
    assign db12 = data[29];
    assign db11 = data[28];
    assign db10 = data[27];
    assign db9 = data[26];
    assign db8 = data[25];
    assign db7 = data[24];
    assign db6 = data[23];
    assign db5 = data[22];
    assign db4 = data[21];
    assign db3 = data[20];
    assign db2 = data[19];
    assign db1 = data[18];
    assign db0 = data[17];
    assign da16 = data[16];
    assign da15 = data[15];
    assign da14 = data[14];
    assign da13 = data[13];
    assign da12 = data[12];
    assign da11 = data[11];
    assign da10 = data[10];
    assign da9 = data[9];
    assign da8 = data[8];
    assign da7 = data[7];
    assign da6 = data[6];
    assign da5 = data[5];
    assign da4 = data[4];
    assign da3 = data[3];
    assign da2 = data[2];
    assign da1 = data[1];
    assign da0 = data[0];
    assign pllclki = refclk;


    // exemplar begin
    // exemplar attribute Inst3_EHXPLLL FREQUENCY_PIN_CLKOS 250.000000
    // exemplar attribute Inst3_EHXPLLL FREQUENCY_PIN_CLKOP 250.000000
    // exemplar attribute Inst3_EHXPLLL FREQUENCY_PIN_CLKI 125.000000
    // exemplar attribute Inst3_EHXPLLL ICP_CURRENT 10
    // exemplar attribute Inst3_EHXPLLL LPF_RESISTOR 24
    // exemplar attribute Inst2_OB IO_TYPE LVDS
    // exemplar attribute Inst1_OB16 IO_TYPE LVDS
    // exemplar attribute Inst1_OB15 IO_TYPE LVDS
    // exemplar attribute Inst1_OB14 IO_TYPE LVDS
    // exemplar attribute Inst1_OB13 IO_TYPE LVDS
    // exemplar attribute Inst1_OB12 IO_TYPE LVDS
    // exemplar attribute Inst1_OB11 IO_TYPE LVDS
    // exemplar attribute Inst1_OB10 IO_TYPE LVDS
    // exemplar attribute Inst1_OB9 IO_TYPE LVDS
    // exemplar attribute Inst1_OB8 IO_TYPE LVDS
    // exemplar attribute Inst1_OB7 IO_TYPE LVDS
    // exemplar attribute Inst1_OB6 IO_TYPE LVDS
    // exemplar attribute Inst1_OB5 IO_TYPE LVDS
    // exemplar attribute Inst1_OB4 IO_TYPE LVDS
    // exemplar attribute Inst1_OB3 IO_TYPE LVDS
    // exemplar attribute Inst1_OB2 IO_TYPE LVDS
    // exemplar attribute Inst1_OB1 IO_TYPE LVDS
    // exemplar attribute Inst1_OB0 IO_TYPE LVDS
    // exemplar end

endmodule
